package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"slices"
	"strings"
	"text/template"
)

var fileFlag = flag.String("file", "", "File to generate types for")
var typesFlag = flag.String("types", "", "Types to take in consdieration. Ex: Packet1,Packet2")

type Field struct {
	Name string
	Type string
}

type StructInfo struct {
	Name   string
	Fields []Field
}

func main() {
	flag.Parse()
	if *fileFlag == "" {
		flag.Usage()
		return
	}
	types := []string{}
	for t := range strings.SplitSeq(*typesFlag, ",") {
		ty := strings.TrimSpace(t)
		if len(ty) > 0 {
			types = append(types, strings.TrimSpace(t))
		}
	}
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *fileFlag, nil, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	var structs []StructInfo

	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			tspec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			s, ok := tspec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structInfo := StructInfo{
				Name: tspec.Name.Name,
			}

			if len(types) > 0 {
				_, found := slices.BinarySearch(types, structInfo.Name)
				if !found {
					continue
				}
			}

			for _, field := range s.Fields.List {
				for _, name := range field.Names {
					structInfo.Fields = append(structInfo.Fields, Field{
						Name: name.Name,
						Type: exprToString(field.Type),
					})
				}
			}

			structs = append(structs, structInfo)
		}
	}

	out, _ := os.Create(fmt.Sprintf("%s_gen.go", (*fileFlag)[0:len(*fileFlag)-3]))
	defer out.Close()
	tmpl.Execute(out, map[string]any{"structs": structs, "package": file.Name})
}

func exprToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.ArrayType:
		// Currently only support slices
		if t.Len == nil {
			return "[]" + exprToString(t.Elt)
		}
		return ""
	default:
		return ""
	}
}

var tmpl = template.Must(template.New("").Parse(`// Code generated by genpacket.go. DO NOT EDIT.

package {{.package}}

import (
    "encoding/binary"
	"bytes"
    "io"
	"fmt"
)

{{range .structs}}
func (p *{{.Name}}) Marshal(opCode byte) []byte {
	b := bytes.Buffer{}
	_ = b.WriteByte(opCode)
    {{range .Fields}}
    {{- if eq .Type "string"}}
	_ = b.WriteByte(byte(len(p.{{.Name}})))
	_, _ = b.WriteString(p.{{.Name}})
    {{- else if eq .Type "[]uint16"}}
	_ = b.WriteByte(byte(len(p.{{.Name}})))
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "int64"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "int32"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "int16"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    p.{{.Name}} = v
    {{- else if eq .Type "int8"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "uint64"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "uint32"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "uint16"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else if eq .Type "uint8"}}
	_ = binary.Write(&b, binary.BigEndian, p.{{.Name}})
    {{- else}}
	panic("Provided unsupported type {{.Type}} for {{.Name}}")
    {{- end}}
    {{end}}
    return b.Bytes()
}
func (p *{{.Name}}) Unmarshal(r io.Reader) error {
    {{range .Fields}}
    {{- if eq .Type "string"}}
	{
		var lengthByte [1]byte
		if _, err := r.Read(lengthByte[:]); err != nil {
			return fmt.Errorf("Could not read string length for {{.Name}}: %w", err)
		}
		length := int(lengthByte[0])
		buf := make([]byte, length)
		if _, err := io.ReadFull(r, buf); err != nil {
			return fmt.Errorf("Could not read string value for {{.Name}}: %w", err)
		}
		p.{{.Name}} = string(buf)
	}
	{{- else if eq .Type "[]uint16" }}
	{
		var lengthByte [1]byte
		if _, err := r.Read(lengthByte[:]); err != nil {
			return fmt.Errorf("Could not read slice length for {{.Name}}: %w", err)
		}
		length := int(lengthByte[0])
		buf := make([]uint16, length)
		for i := range buf {
			if err := binary.Read(r, binary.BigEndian, &buf[i]); err != nil {
				return fmt.Errorf("Could not read uint16 for {{.Name}}: %w", err)
			}
		}
		p.{{.Name}} = buf
	}
    {{- else if eq .Type "int64"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read int64 for {{.Name}}: %w", err)
    }
    {{- else if eq .Type "int32"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read int32 for {{.Name}}: %w", err)
    }
    {{- else if eq .Type "int16"}}
    var v int16
    if err := binary.Read(r, binary.BigEndian, &v); err != nil {
        return fmt.Errorf("Could not read int16 for {{.Name}}: %w", err)
    }
    p.{{.Name}} = v
    {{- else if eq .Type "int8"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read int8 for {{.Name}}: %w", err)
    }
    {{- else if eq .Type "uint64"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read uint64 for {{.Name}}: %w", err)
    }
    {{- else if eq .Type "uint32"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read uint32 for {{.Name}}: %w", err)
    }
    {{- else if eq .Type "uint16"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read uint16 for {{.Name}}: %w", err)
    }
    {{- else if eq .Type "uint8"}}
    if err := binary.Read(r, binary.BigEndian, &p.{{.Name}}); err != nil {
        return fmt.Errorf("Could not read uint8 for {{.Name}}: %w", err)
    }
    {{- else}}
	panic("Provided unsupported type {{.Type}} for {{.Name}}")
    {{- end}}
    {{end}}
    return nil
}
{{end}}
`))
